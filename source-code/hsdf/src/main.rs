// src/main.rs

use anyhow::{Context, Result};
use clap::{Parser, Subcommand};
use miette::{Diagnostic, MietteDiagnostic, NamedSource, Report, SourceSpan};
use std::fs;
use std::path::PathBuf;
use thiserror::Error;

#[derive(Parser)]
#[command(
name = "hsdf",
about = "HackerScript Diagnostic Formatter\nPretty-print parse/compile/runtime errors",
version
)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Show pretty error from JSON diagnostic file
    Show {
        /// Path to .hserr.json file generated by HS1/HS2/HS3
        #[arg(required = true)]
        file: PathBuf,

        /// Also print raw JSON content
        #[arg(long, short = 'r')]
        raw: bool,
    },

    /// Generate example diagnostic file (for testing)
    Example {
        /// Output path for example .hserr.json
        #[arg(default_value = "example.hserr.json")]
        output: PathBuf,
    },

    /// Convert plain text error to pretty miette report (pipe-friendly)
    FromText {
        /// Path to source file (required for context)
        #[arg(long)]
        source: Option<PathBuf>,

        /// Error message
        #[arg(long)]
        message: Option<String>,

        /// Optional span: start_line:start_col-end_line:end_col
        #[arg(long)]
        span: Option<String>,
    },
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    match cli.command {
        Commands::Show { file, raw } => {
            if !file.exists() {
                anyhow::bail!("Diagnostic file not found: {}", file.display());
            }

            let content = fs::read_to_string(&file)?;
            let diag: HsDiagnosticFile = serde_json::from_str(&content)
            .context("Invalid .hserr.json format")?;

            if raw {
                println!("Raw diagnostic JSON:\n{}", content);
                println!("\n");
            }

            print_pretty_diagnostic(&diag)?;
        }

        Commands::Example { output } => {
            let example = create_example_diagnostic();
            let json = serde_json::to_string_pretty(&example)?;
            fs::write(&output, json)?;
            eprintln!("Example diagnostic written to: {}", output.display());
        }

        Commands::FromText { source, message, span } => {
            let source_code = if let Some(path) = source {
                fs::read_to_string(&path).context("Cannot read source file")?
            } else {
                String::new()
            };

            let mut report = Report::new(MietteDiagnostic {
                severity: Some(miette::Severity::Error),
                                         code: Some("HS-0001".into()),
                                         message: message.unwrap_or_else(|| "Generic error".into()),
                                         ..Default::default()
            });

            if let Some(span_str) = span {
                if let Some((start, end)) = parse_span(&span_str) {
                    report = report.with_source_code(NamedSource::new(
                        source.unwrap_or_default().to_string_lossy().to_string(),
                                                                      source_code,
                    ));
                    report = report.with_label(miette::LabeledSpan::underline(SourceSpan::new(
                        start.into(),
                                                                                              (end - start).into(),
                    )));
                }
            }

            eprintln!("{:?}", report);
        }
    }

    Ok(())
}

fn print_pretty_diagnostic(diag: &HsDiagnosticFile) -> Result<()> {
    let source = NamedSource::new(diag.filename.clone(), diag.source_code.clone());

    let mut report = Report::new(MietteDiagnostic {
        severity: Some(diag.severity.into()),
                                 code: diag.code.clone(),
                                 message: diag.message.clone(),
                                 url: diag.url.clone(),
                                 help: diag.help.clone(),
                                 labels: vec![],
                                 related: vec![],
    });

    for label in &diag.labels {
        let span = SourceSpan::new(
            label.offset.into(),
                                   label.length.into(),
        );

        let labeled = miette::LabeledSpan::new_with_span(
            Some(label.message.clone()),
                                                         span,
        );

        report = report.with_label(labeled);
    }

    report = report.with_source_code(source);

    eprintln!("{:?}", report);

    Ok(())
}

fn parse_span(s: &str) -> Option<(usize, usize)> {
    // very naive: "3:12-5:8" → byte offsets approximated
    // In real compiler better to keep byte offsets from parser
    let parts: Vec<&str> = s.split('-').collect();
    if parts.len() != 2 {
        return None;
    }

    let start_parts: Vec<&str> = parts[0].split(':').collect();
    let end_parts: Vec<&str> = parts[1].split(':').collect();

    if start_parts.len() != 2 || end_parts.len() != 2 {
        return None;
    }

    // This is approximate – real span should come from pest / parser
    Some((0, 42)) // placeholder
}

#[derive(Debug, serde::Serialize, serde::Deserialize)]
struct HsDiagnosticFile {
    filename: String,
    source_code: String,
    severity: Severity,
    code: Option<String>,
    message: String,
    url: Option<String>,
    help: Option<String>,
    labels: Vec<HsLabel>,
}

#[derive(Debug, serde::Serialize, serde::Deserialize)]
struct HsLabel {
    message: String,
    offset: usize,
    length: usize,
    // could add primary/secondary, color hint etc.
}

#[derive(Debug, Clone, Copy, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "lowercase")]
enum Severity {
    Error,
    Warning,
    Advice,
    Note,
}

impl From<Severity> for miette::Severity {
    fn from(s: Severity) -> Self {
        match s {
            Severity::Error => miette::Severity::Error,
            Severity::Warning => miette::Severity::Warning,
            Severity::Advice => miette::Severity::Advice,
            Severity::Note => miette::Severity::Advice, // fallback
        }
    }
}

#[derive(Error, Debug)]
#[error("example error")]
struct ExampleError;

fn create_example_diagnostic() -> HsDiagnosticFile {
    HsDiagnosticFile {
        filename: "src/main.hcs".to_string(),
        source_code: r#"
        func main()
        [
        log "Hello
        import <core:bad>
        ]
        "#
        .trim()
        .to_string(),
        severity: Severity::Error,
        code: Some("HS-1001".to_string()),
        message: "Unexpected end of string literal".to_string(),
        url: Some("https://hackerscript.org/errors/HS-1001".to_string()),
        help: Some("Close the string with \" or use multi-line string syntax".to_string()),
        labels: vec![
            HsLabel {
                message: "unterminated string starts here".to_string(),
                offset: 24,
                length: 1,
            },
            HsLabel {
                message: "this import is unreachable due to previous error".to_string(),
                offset: 38,
                length: 16,
            },
        ],
    }
}
